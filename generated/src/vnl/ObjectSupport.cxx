
// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/ObjectSupport.hxx>
#include <vnl/Type.hxx>
#include <vnl/Var.h>

namespace vnl {

const uint32_t ObjectBase::VNI_HASH;
const uint32_t ObjectBase::NUM_FIELDS;
const int32_t ObjectBase::ERROR;
const int32_t ObjectBase::WARN;
const int32_t ObjectBase::INFO;
const int32_t ObjectBase::DEBUG;

ObjectBase::ObjectBase(const vnl::String& domain_, const vnl::String& topic_)
{
	vnl_log_level = INFO;
	vnl_msg_timeout = 1000000;
	vnl_heartbeat_interval = 1000000;
	vnl::read_config(domain_, topic_, "vnl_log_level", vnl_log_level);
	vnl::read_config(domain_, topic_, "vnl_msg_timeout", vnl_msg_timeout);
	vnl::read_config(domain_, topic_, "vnl_heartbeat_interval", vnl_heartbeat_interval);
}

int ObjectBase::get_field_index(vnl::Hash32 _hash) const {
	switch(_hash) {
		case 0x482df535: return 0;
		case 0x604b2647: return 1;
		case 0xd26001ae: return 2;
		default: return -1;
	}
}

const char* ObjectBase::get_field_name(int _index) const {
	switch(_index) {
		case 0: return "vnl_log_level";
		case 1: return "vnl_msg_timeout";
		case 2: return "vnl_heartbeat_interval";
		default: return 0;
	}
}

void ObjectBase::get_field(int _index, vnl::String& _str) const {
	switch(_index) {
		case 0: vnl::to_string(_str, vnl_log_level); break;
		case 1: vnl::to_string(_str, vnl_msg_timeout); break;
		case 2: vnl::to_string(_str, vnl_heartbeat_interval); break;
	}
}

void ObjectBase::set_field(int _index, const vnl::String& _str) {
	switch(_index) {
		case 0: vnl::from_string(_str, vnl_log_level); break;
		case 1: vnl::from_string(_str, vnl_msg_timeout); break;
		case 2: vnl::from_string(_str, vnl_heartbeat_interval); break;
	}
}

void ObjectBase::get_field(int _index, vnl::io::TypeOutput& _out) const {
	switch(_index) {
		case 0: vnl::write(_out, vnl_log_level); break;
		case 1: vnl::write(_out, vnl_msg_timeout); break;
		case 2: vnl::write(_out, vnl_heartbeat_interval); break;
		default: _out.putNull();
	}
}

void ObjectBase::set_field(int _index, vnl::io::TypeInput& _in) {
	switch(_index) {
		case 0: vnl::read(_in, vnl_log_level); break;
		case 1: vnl::read(_in, vnl_msg_timeout); break;
		case 2: vnl::read(_in, vnl_heartbeat_interval); break;
	}
}

void ObjectBase::get_field(int _index, vnl::Var& _var) const {
	switch(_index) {
		case 0: _var = vnl_log_level; break;
		case 1: _var = vnl_msg_timeout; break;
		case 2: _var = vnl_heartbeat_interval; break;
		default: _var.clear();
	}
}

void ObjectBase::set_field(int _index, const vnl::Var& _var) {
	switch(_index) {
		case 0: _var.to(vnl_log_level); break;
		case 1: _var.to(vnl_msg_timeout); break;
		case 2: _var.to(vnl_heartbeat_interval); break;
	}
}

bool ObjectBase::vni_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args) {
	switch(_hash) {
	case 0x482df535: 
		if(_num_args == 1) {
			vnl::read(_in, vnl_log_level);
			return true;
		}
		break;
	case 0x604b2647: 
		if(_num_args == 1) {
			vnl::read(_in, vnl_msg_timeout);
			return true;
		}
		break;
	case 0xd26001ae: 
		if(_num_args == 1) {
			vnl::read(_in, vnl_heartbeat_interval);
			return true;
		}
		break;
	case 0x34266241: 
		switch(_num_args) {
			case 2: {
				vnl::Hash32 name;
				vnl::read(_in, name);
				vnl::String value;
				vnl::read(_in, value);
				if(!_in.error()) {
					set_config(name, value);
					return true;
				}
			}
			break;
		}
		break;
	case 0xe8592f85: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					exit();
					return true;
				}
			}
			break;
		}
		break;
	}
	return Super::vni_call(_in, _hash, _num_args);
}

bool ObjectBase::vni_const_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args, vnl::io::TypeOutput& _out) {
	switch(_hash) {
	case 0x482df535: 
		if(_num_args == 0) {
			vnl::write(_out, vnl_log_level);
			return true;
		}
		break;
	case 0x604b2647: 
		if(_num_args == 0) {
			vnl::write(_out, vnl_msg_timeout);
			return true;
		}
		break;
	case 0xd26001ae: 
		if(_num_args == 0) {
			vnl::write(_out, vnl_heartbeat_interval);
			return true;
		}
		break;
	case 0x1b85d99: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					vnl::Map<vnl::String, vnl::String > _res = get_config_map();
					vnl::write(_out, _res);
					return true;
				}
			}
			break;
		}
		break;
	case 0x9abb388d: 
		switch(_num_args) {
			case 1: {
				vnl::Hash32 name;
				vnl::read(_in, name);
				if(!_in.error()) {
					vnl::String _res = get_config(name);
					vnl::write(_out, _res);
					return true;
				}
			}
			break;
		}
		break;
	case 0xc5f1083a: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					vnl::String _res = get_private_domain();
					vnl::write(_out, _res);
					return true;
				}
			}
			break;
		}
		break;
	}
	return Super::vni_const_call(_in, _hash, _num_args, _out);
}

bool ObjectBase::handle_switch(vnl::Value* _sample, vnl::Packet* _packet) {
	switch(_sample->get_vni_hash()) {
	case 0xcdc22e1f: handle(*((vnl::Shutdown*)_sample), *_packet); return true;
	}
	return Super::handle_switch(_sample, _packet);
}

bool ObjectBase::handle_switch(vnl::Value* _sample, vnl::Basic* _input) {
	switch(_sample->get_vni_hash()) {
	case 0xcdc22e1f: handle(*((vnl::Shutdown*)_sample), _input); return true;
	}
	return Super::handle_switch(_sample, _input);
}


} // namespace
