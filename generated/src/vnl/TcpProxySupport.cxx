
// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/TcpProxySupport.hxx>
#include <vnl/Type.hxx>

namespace vnl {

const uint32_t TcpProxyBase::VNI_HASH;
const uint32_t TcpProxyBase::NUM_FIELDS;

int TcpProxyBase::get_field_index(vnl::Hash32 _hash) const {
	switch(_hash) {
		case 0x482df535: return 0;
		case 0x604b2647: return 1;
		case 0xd26001ae: return 2;
		case 0x55f7671e: return 3;
		case 0x1f5839d4: return 4;
		default: return -1;
	}
}

const char* TcpProxyBase::get_field_name(int _index) const {
	switch(_index) {
		case 0: return "vnl_log_level";
		case 1: return "vnl_msg_timeout";
		case 2: return "vnl_heartbeat_interval";
		case 3: return "error_interval";
		case 4: return "are_connected";
		default: return 0;
	}
}

void TcpProxyBase::get_field(int _index, vnl::String& _str) const {
	switch(_index) {
		case 0: vnl::to_string(_str, vnl_log_level); break;
		case 1: vnl::to_string(_str, vnl_msg_timeout); break;
		case 2: vnl::to_string(_str, vnl_heartbeat_interval); break;
		case 3: vnl::to_string(_str, error_interval); break;
		case 4: vnl::to_string(_str, are_connected); break;
	}
}

void TcpProxyBase::set_field(int _index, const vnl::String& _str) {
	switch(_index) {
		case 0: vnl::from_string(_str, vnl_log_level); break;
		case 1: vnl::from_string(_str, vnl_msg_timeout); break;
		case 2: vnl::from_string(_str, vnl_heartbeat_interval); break;
		case 3: vnl::from_string(_str, error_interval); break;
		case 4: vnl::from_string(_str, are_connected); break;
	}
}

void TcpProxyBase::get_field(int _index, vnl::io::TypeOutput& _out) const {
	switch(_index) {
		case 0: vnl::write(_out, vnl_log_level); break;
		case 1: vnl::write(_out, vnl_msg_timeout); break;
		case 2: vnl::write(_out, vnl_heartbeat_interval); break;
		case 3: vnl::write(_out, error_interval); break;
		case 4: vnl::write(_out, are_connected); break;
		default: _out.putNull();
	}
}

void TcpProxyBase::set_field(int _index, vnl::io::TypeInput& _in) {
	switch(_index) {
		case 0: vnl::read(_in, vnl_log_level); break;
		case 1: vnl::read(_in, vnl_msg_timeout); break;
		case 2: vnl::read(_in, vnl_heartbeat_interval); break;
		case 3: vnl::read(_in, error_interval); break;
		case 4: vnl::read(_in, are_connected); break;
	}
}

bool TcpProxyBase::vni_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args) {
	switch(_hash) {
	}
	return Super::vni_call(_in, _hash, _num_args);
}

bool TcpProxyBase::vni_const_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args, vnl::io::TypeOutput& _out) {
	switch(_hash) {
	}
	return Super::vni_const_call(_in, _hash, _num_args, _out);
}

bool TcpProxyBase::handle_switch(vnl::Value* _sample, vnl::Packet* _packet) {
	switch(_sample->get_vni_hash()) {
	}
	return Super::handle_switch(_sample, _packet);
}

bool TcpProxyBase::handle_switch(vnl::Value* _sample, vnl::Basic* _input) {
	switch(_sample->get_vni_hash()) {
	}
	return Super::handle_switch(_sample, _input);
}


} // namespace
