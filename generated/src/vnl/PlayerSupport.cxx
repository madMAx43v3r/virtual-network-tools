
// AUTO GENERATED by virtual-network-interface codegen

#include <vnl/PlayerSupport.hxx>
#include <vnl/Type.hxx>
#include <vnl/Var.h>

namespace vnl {

const uint32_t PlayerBase::VNI_HASH;
const uint32_t PlayerBase::NUM_FIELDS;

int PlayerBase::get_field_index(vnl::Hash32 _hash) const {
	switch(_hash) {
		case 0x482df535: return 0;
		case 0x604b2647: return 1;
		case 0xd26001ae: return 2;
		case 0xb60d3446: return 3;
		case 0xa9decee6: return 4;
		case 0xca73652e: return 5;
		case 0x5902c26f: return 6;
		case 0x3cc6f24e: return 7;
		case 0x51558795: return 8;
		case 0xd129c896: return 9;
		default: return -1;
	}
}

const char* PlayerBase::get_field_name(int _index) const {
	switch(_index) {
		case 0: return "vnl_log_level";
		case 1: return "vnl_msg_timeout";
		case 2: return "vnl_heartbeat_interval";
		case 3: return "filename";
		case 4: return "domain_blacklist";
		case 5: return "topic_blacklist";
		case 6: return "autostart";
		case 7: return "autoloop";
		case 8: return "autoshutdown";
		case 9: return "interval";
		default: return 0;
	}
}

void PlayerBase::get_field(int _index, vnl::String& _str) const {
	switch(_index) {
		case 0: vnl::to_string(_str, vnl_log_level); break;
		case 1: vnl::to_string(_str, vnl_msg_timeout); break;
		case 2: vnl::to_string(_str, vnl_heartbeat_interval); break;
		case 3: vnl::to_string(_str, filename); break;
		case 4: vnl::to_string(_str, domain_blacklist); break;
		case 5: vnl::to_string(_str, topic_blacklist); break;
		case 6: vnl::to_string(_str, autostart); break;
		case 7: vnl::to_string(_str, autoloop); break;
		case 8: vnl::to_string(_str, autoshutdown); break;
		case 9: vnl::to_string(_str, interval); break;
	}
}

void PlayerBase::set_field(int _index, const vnl::String& _str) {
	switch(_index) {
		case 0: vnl::from_string(_str, vnl_log_level); break;
		case 1: vnl::from_string(_str, vnl_msg_timeout); break;
		case 2: vnl::from_string(_str, vnl_heartbeat_interval); break;
		case 3: vnl::from_string(_str, filename); break;
		case 4: vnl::from_string(_str, domain_blacklist); break;
		case 5: vnl::from_string(_str, topic_blacklist); break;
		case 6: vnl::from_string(_str, autostart); break;
		case 7: vnl::from_string(_str, autoloop); break;
		case 8: vnl::from_string(_str, autoshutdown); break;
		case 9: vnl::from_string(_str, interval); break;
	}
}

void PlayerBase::get_field(int _index, vnl::io::TypeOutput& _out) const {
	switch(_index) {
		case 0: vnl::write(_out, vnl_log_level); break;
		case 1: vnl::write(_out, vnl_msg_timeout); break;
		case 2: vnl::write(_out, vnl_heartbeat_interval); break;
		case 3: vnl::write(_out, filename); break;
		case 4: vnl::write(_out, domain_blacklist); break;
		case 5: vnl::write(_out, topic_blacklist); break;
		case 6: vnl::write(_out, autostart); break;
		case 7: vnl::write(_out, autoloop); break;
		case 8: vnl::write(_out, autoshutdown); break;
		case 9: vnl::write(_out, interval); break;
		default: _out.putNull();
	}
}

void PlayerBase::set_field(int _index, vnl::io::TypeInput& _in) {
	switch(_index) {
		case 0: vnl::read(_in, vnl_log_level); break;
		case 1: vnl::read(_in, vnl_msg_timeout); break;
		case 2: vnl::read(_in, vnl_heartbeat_interval); break;
		case 3: vnl::read(_in, filename); break;
		case 4: vnl::read(_in, domain_blacklist); break;
		case 5: vnl::read(_in, topic_blacklist); break;
		case 6: vnl::read(_in, autostart); break;
		case 7: vnl::read(_in, autoloop); break;
		case 8: vnl::read(_in, autoshutdown); break;
		case 9: vnl::read(_in, interval); break;
	}
}

void PlayerBase::get_field(int _index, vnl::Var& _var) const {
	switch(_index) {
		case 0: _var = vnl_log_level; break;
		case 1: _var = vnl_msg_timeout; break;
		case 2: _var = vnl_heartbeat_interval; break;
		case 3: _var = filename; break;
		case 4: _var = domain_blacklist; break;
		case 5: _var = topic_blacklist; break;
		case 6: _var = autostart; break;
		case 7: _var = autoloop; break;
		case 8: _var = autoshutdown; break;
		case 9: _var = interval; break;
		default: _var.clear();
	}
}

void PlayerBase::set_field(int _index, const vnl::Var& _var) {
	switch(_index) {
		case 0: _var.to(vnl_log_level); break;
		case 1: _var.to(vnl_msg_timeout); break;
		case 2: _var.to(vnl_heartbeat_interval); break;
		case 3: _var.to(filename); break;
		case 4: _var.to(domain_blacklist); break;
		case 5: _var.to(topic_blacklist); break;
		case 6: _var.to(autostart); break;
		case 7: _var.to(autoloop); break;
		case 8: _var.to(autoshutdown); break;
		case 9: _var.to(interval); break;
	}
}

bool PlayerBase::vni_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args) {
	switch(_hash) {
	case 0xb60d3446: 
		if(_num_args == 1) {
			vnl::read(_in, filename);
			return true;
		}
		break;
	case 0xa9decee6: 
		if(_num_args == 1) {
			vnl::read(_in, domain_blacklist);
			return true;
		}
		break;
	case 0xca73652e: 
		if(_num_args == 1) {
			vnl::read(_in, topic_blacklist);
			return true;
		}
		break;
	case 0x5902c26f: 
		if(_num_args == 1) {
			vnl::read(_in, autostart);
			return true;
		}
		break;
	case 0x3cc6f24e: 
		if(_num_args == 1) {
			vnl::read(_in, autoloop);
			return true;
		}
		break;
	case 0x51558795: 
		if(_num_args == 1) {
			vnl::read(_in, autoshutdown);
			return true;
		}
		break;
	case 0xd129c896: 
		if(_num_args == 1) {
			vnl::read(_in, interval);
			return true;
		}
		break;
	case 0x9b2fb63: 
		switch(_num_args) {
			case 1: {
				int64_t time = 0;
				vnl::read(_in, time);
				if(!_in.error()) {
					seek(time);
					return true;
				}
			}
			break;
		}
		break;
	case 0x25c4211b: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					play();
					return true;
				}
			}
			break;
		}
		break;
	case 0x5c4affeb: 
		switch(_num_args) {
			case 1: {
				vnl::String file;
				vnl::read(_in, file);
				if(!_in.error()) {
					open(file);
					return true;
				}
			}
			break;
		}
		break;
	case 0x73fed50f: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					scan();
					return true;
				}
			}
			break;
		}
		break;
	case 0xbd19b5cb: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					reset();
					return true;
				}
			}
			break;
		}
		break;
	case 0xe1fbf4c8: 
		switch(_num_args) {
			case 1: {
				float pos = 0;
				vnl::read(_in, pos);
				if(!_in.error()) {
					seek_rel(pos);
					return true;
				}
			}
			break;
		}
		break;
	case 0xe745115d: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					pause();
					return true;
				}
			}
			break;
		}
		break;
	case 0xf2cbfddb: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					stop();
					return true;
				}
			}
			break;
		}
		break;
	}
	return Super::vni_call(_in, _hash, _num_args);
}

bool PlayerBase::vni_const_call(vnl::io::TypeInput& _in, uint32_t _hash, int _num_args, vnl::io::TypeOutput& _out) {
	switch(_hash) {
	case 0xb60d3446: 
		if(_num_args == 0) {
			vnl::write(_out, filename);
			return true;
		}
		break;
	case 0xa9decee6: 
		if(_num_args == 0) {
			vnl::write(_out, domain_blacklist);
			return true;
		}
		break;
	case 0xca73652e: 
		if(_num_args == 0) {
			vnl::write(_out, topic_blacklist);
			return true;
		}
		break;
	case 0x5902c26f: 
		if(_num_args == 0) {
			vnl::write(_out, autostart);
			return true;
		}
		break;
	case 0x3cc6f24e: 
		if(_num_args == 0) {
			vnl::write(_out, autoloop);
			return true;
		}
		break;
	case 0x51558795: 
		if(_num_args == 0) {
			vnl::write(_out, autoshutdown);
			return true;
		}
		break;
	case 0xd129c896: 
		if(_num_args == 0) {
			vnl::write(_out, interval);
			return true;
		}
		break;
	case 0x4370e1e0: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					vnl::info::PlayerStatus _res = get_status();
					vnl::write(_out, _res);
					return true;
				}
			}
			break;
		}
		break;
	case 0x71ce1b5a: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					vnl::Array<vnl::Topic > _res = get_topics();
					vnl::write(_out, _res);
					return true;
				}
			}
			break;
		}
		break;
	case 0xf73490b7: 
		switch(_num_args) {
			case 0: {
				if(!_in.error()) {
					vnl::Map<vnl::Hash32, vnl::info::Type > _res = get_type_info();
					vnl::write(_out, _res);
					return true;
				}
			}
			break;
		}
		break;
	}
	return Super::vni_const_call(_in, _hash, _num_args, _out);
}

bool PlayerBase::handle_switch(vnl::Value* _sample, vnl::Packet* _packet) {
	switch(_sample->get_vni_hash()) {
	}
	return Super::handle_switch(_sample, _packet);
}

bool PlayerBase::handle_switch(vnl::Value* _sample, vnl::Basic* _input) {
	switch(_sample->get_vni_hash()) {
	}
	return Super::handle_switch(_sample, _input);
}


} // namespace
